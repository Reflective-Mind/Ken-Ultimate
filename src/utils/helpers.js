// Helper functions for the mesh generator

// Creates a multi-material mesh from arrays of geometries and materials
export const createMultiMaterialMesh = (geometries, materials) => {
  if (!Array.isArray(geometries) || !Array.isArray(materials)) {
    console.error('createMultiMaterialMesh: Both geometries and materials must be arrays');
    return null;
  }
  
  if (geometries.length !== materials.length) {
    console.error(`createMultiMaterialMesh: Number of geometries (${geometries.length}) does not match number of materials (${materials.length})`);
    return null;
  }
  
  const group = new THREE.Group();
  
  for (let i = 0; i < geometries.length; i++) {
    const mesh = new THREE.Mesh(geometries[i], materials[i]);
    mesh.castShadow = true;
    mesh.receiveShadow = true;
    // Add a meaningful name if not set explicitly
    if (!mesh.name) mesh.name = `part_${i + 1}`;
    group.add(mesh);
  }
  
  return group;
};

// Export mesh to OBJ format for Unreal Engine
export const exportToOBJ = (mesh, exportMaterials = true) => {
  if (!mesh) return null;
  
  // Initialize OBJ exporter
  const exporter = new THREE.OBJExporter();
  
  // Export to OBJ format
  const objData = exporter.parse(mesh);
  
  // If materials should be exported and we have a material
  if (exportMaterials) {
    // Create MTL content
    const mtlData = generateMTL(mesh);
    return { obj: objData, mtl: mtlData };
  }
  
  return { obj: objData, mtl: null };
};

// Generate MTL file content from mesh materials
const generateMTL = (mesh) => {
  let mtlContent = '# MTL file generated by Unreal Engine Mesh Generator\n\n';
  const processedMaterials = new Map();
  
  // Helper function to process a mesh's material
  const processMaterial = (object) => {
    if (object.isMesh && object.material) {
      const material = object.material;
      
      // Skip if material has already been processed
      if (processedMaterials.has(material.uuid)) return;
      
      // Define a name for the material
      const matName = material.name || `material_${processedMaterials.size + 1}`;
      
      // Start material definition
      mtlContent += `newmtl ${matName}\n`;
      
      // Add common properties
      mtlContent += 'illum 2\n'; // Illumination model
      
      // Add color properties
      if (material.color) {
        const color = material.color;
        mtlContent += `Kd ${color.r.toFixed(6)} ${color.g.toFixed(6)} ${color.b.toFixed(6)}\n`; // Diffuse
        
        // For MeshStandardMaterial, add roughness and metalness
        if (material.roughness !== undefined) {
          mtlContent += `Ns ${((1 - material.roughness) * 100).toFixed(6)}\n`; // Specular highlight
        } else {
          mtlContent += 'Ns 50.000000\n';
        }
        
        if (material.metalness !== undefined) {
          const specularColor = material.metalness;
          mtlContent += `Ks ${specularColor} ${specularColor} ${specularColor}\n`; // Specular
        } else {
          mtlContent += 'Ks 0.500000 0.500000 0.500000\n';
        }
      } else {
        // Default values
        mtlContent += 'Kd 0.800000 0.800000 0.800000\n';
        mtlContent += 'Ks 0.500000 0.500000 0.500000\n';
        mtlContent += 'Ns 50.000000\n';
      }
      
      // Add transparency
      if (material.transparent && material.opacity < 1.0) {
        mtlContent += `d ${material.opacity.toFixed(6)}\n`;
      } else {
        mtlContent += 'd 1.000000\n';
      }
      
      // Add emissive color if present
      if (material.emissive && material.emissiveIntensity > 0) {
        const emissive = material.emissive;
        const intensity = material.emissiveIntensity;
        mtlContent += `Ke ${(emissive.r * intensity).toFixed(6)} ${(emissive.g * intensity).toFixed(6)} ${(emissive.b * intensity).toFixed(6)}\n`;
      } else {
        mtlContent += 'Ke 0.000000 0.000000 0.000000\n';
      }
      
      // Add a blank line after each material
      mtlContent += '\n';
      
      // Mark material as processed
      processedMaterials.set(material.uuid, matName);
    }
  };
  
  // Process mesh or traverse group to find all materials
  if (mesh.isMesh) {
    processMaterial(mesh);
  } else if (mesh.isGroup) {
    mesh.traverse(processMaterial);
  }
  
  return mtlContent;
};

// Setup lighting for the scene
export const setupLighting = (scene) => {
  const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
  scene.add(ambientLight);

  const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
  directionalLight.position.set(5, 10, 7);
  directionalLight.castShadow = true;
  // Better shadow quality
  directionalLight.shadow.mapSize.width = 1024;
  directionalLight.shadow.mapSize.height = 1024;
  directionalLight.shadow.camera.near = 0.5;
  directionalLight.shadow.camera.far = 50;
  directionalLight.shadow.bias = -0.001;
  scene.add(directionalLight);

  // Add a fill light from another angle
  const fillLight = new THREE.DirectionalLight(0xffffff, 0.3);
  fillLight.position.set(-5, 2, -7);
  scene.add(fillLight);
  
  return { ambientLight, directionalLight, fillLight };
}; 